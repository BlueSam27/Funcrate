<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Space Gravity Simulation</title>
  <!-- Google Font -->
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700&display=swap" rel="stylesheet">
  <style>
    /* Reset & Global Styles */
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      font-family: 'Roboto', sans-serif;
      color: #333;
      background: #f0f2f5;
    }
    /* Canvas Styles */
    #simulation {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #111;
      display: block;
      user-select: none;
    }
    /* Sidebar Styles */
    #sidebar {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 320px;
      max-width: 100%;
      background: #fff;
      padding: 20px;
      border-left: 1px solid #ddd;
      box-shadow: -4px 0 12px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      z-index: 100;
    }
    details {
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 5px 10px 10px;
      background: #f9f9f9;
    }
    details summary {
      font-weight: 500;
      font-size: 1em;
      cursor: pointer;
      outline: none;
      margin: -5px -10px 10px;
      padding: 5px 10px;
    }
    details[open] { background: #fff; }
    details form, details div { margin-top: 5px; }
    form label { font-size: 0.9em; }
    form input[type="number"] {
      padding: 8px;
      font-size: 1em;
      border: 1px solid #ccc;
      border-radius: 4px;
      transition: border-color 0.2s;
      width: 100%;
    }
    form input[type="number"]:focus { border-color: #007bff; outline: none; }
    form input[type="checkbox"] { margin-right: 8px; }
    #buttons, #simControls, #presets {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      align-items: center;
    }
    button {
      flex: 1;
      padding: 10px;
      font-size: 1em;
      border: none;
      border-radius: 4px;
      background: #007bff;
      color: #fff;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #0056b3; }
    #instructions { font-size: 0.85em; line-height: 1.4; color: #666; }
    /* Toggle Sidebar Button */
    #toggleSidebar {
      position: fixed;
      top: 10px;
      right: 330px;
      z-index: 110;
      padding: 8px 12px;
      background: #007bff;
      color: #fff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: right 0.3s ease;
    }
    /* Planet Info Popup */
    #planetInfo {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 5px 10px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 0.85em;
      z-index: 200;
      display: none;
    }
    /* Debug Menu */
    #debugMenu {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #888;
      color: #fff;
      padding: 20px;
      border: 2px solid #555;
      border-radius: 8px;
      z-index: 300;
      display: none;
      min-width: 300px;
    }
    #debugMenu .close-btn {
      position: absolute;
      top: 5px;
      right: 8px;
      background: transparent;
      border: none;
      color: #fff;
      font-size: 1.2em;
      cursor: pointer;
    }
    /* FPS Counter */
    #fpsCounter {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: #0f0;
      padding: 5px 10px;
      border-radius: 4px;
      font-family: monospace;
      display: none;
      z-index: 250;
    }
  </style>
</head>
<body>
  <canvas id="simulation"></canvas>
  
  <!-- Debug Menu -->
  <div id="debugMenu">
    <button class="close-btn" id="closeDebug">x</button>
    <h3>Debug Menu</h3>
    <p>This is a debug menu.</p>
    <button id="toggleFPS">Toggle FPS Counter</button>
    <br><br>
    <label for="spawnChanceInput">Station Spawn Chance (%): </label>
    <input type="number" id="spawnChanceInput" value="5" min="0" max="100" step="0.1">
    <br><br>
    <label for="numFragmentsInput">Roche Splitting Fragments:</label>
    <input type="number" id="numFragmentsInput" value="4" min="2" max="16" step="1">
    <br><br>
    <!-- New Controls for Roche Limit Circle -->
    <label for="rocheLimitColorInput">Roche Limit Circle Color:</label>
    <input type="color" id="rocheLimitColorInput" value="#ff0000">
    <br><br>
    <label for="rocheLimitBrightnessInput">Roche Limit Circle Brightness:</label>
    <input type="number" id="rocheLimitBrightnessInput" value="0.3" min="0" max="1" step="0.05">
  </div>
  
  <!-- FPS Counter -->
  <div id="fpsCounter">FPS: 0</div>
  
  <!-- Sidebar -->
  <div id="sidebar">
    <!-- Add New Body -->
    <details open>
      <summary>Add New Body</summary>
      <form id="addBodyForm">
        <label for="posX">Pos X:</label>
        <input type="number" id="posX" step="any" required>
        <label for="posY">Pos Y:</label>
        <input type="number" id="posY" step="any" required>
        <label for="velX">Vel X:</label>
        <input type="number" id="velX" step="any" value="0" required>
        <label for="velY">Vel Y:</label>
        <input type="number" id="velY" step="any" value="0" required>
        <label for="mass">Mass:</label>
        <input type="number" id="mass" step="any" value="1000" required>
        <label>
          <input type="checkbox" id="static">
          Static (Fixed in space)
        </label>
        <!-- Tag Options -->
        <div style="margin-top:10px;">
          <strong>Tags:</strong><br>
          <div><label><input type="checkbox" id="tagStar"> Star</label></div>
          <div><label><input type="checkbox" id="tagRings"> Rings</label></div>
          <div><label><input type="checkbox" id="tagGas"> Gas</label></div>
          <div><label><input type="checkbox" id="tagSupportLife"> Support Life</label></div>
        </div>
        <div id="buttons" style="margin-top:10px;">
          <button type="submit">Add Body</button>
          <button type="button" id="clearFields">Clear</button>
        </div>
      </form>
    </details>
    
    <!-- Simulation Controls -->
    <details open>
      <summary>Simulation Controls</summary>
      <div id="simControls">
        <button id="pauseBtn">⏸</button>
        <label for="speedInput">Speed:</label>
        <input type="number" id="speedInput" value="1" step="0.1" style="width: 80px;">
      </div>
      <div id="collisionControls" style="margin-top:10px;">
        <button id="toggleCombineBtn">Combine on Collision: ON</button>
      </div>
      <div id="orbitStarControl" style="margin-top:10px;">
        <button id="toggleOrbitStar">Only Orbit Star: OFF</button>
      </div>
      <!-- Toggle for displaying Roche Limit -->
      <div id="rocheLimitControl" style="margin-top:10px;">
        <label><input type="checkbox" id="toggleRocheLimit"> Show Roche Limit</label>
      </div>
    </details>
    
    <!-- Trails -->
    <details open>
      <summary>Trails</summary>
      <div>
        <label><input type="checkbox" id="showTrails" checked> Show Trails</label>
        <div id="trailOptions" style="margin-top: 5px;">
          <label><input type="checkbox" id="usePlanetColorCheckbox" checked> Use Planet Color</label>
          <label>Trail Color: <input type="color" id="trailColorPicker" value="#ff0000"></label>
          <label>Trail Lifespan: <input type="number" id="trailLifespanInput" value="2000" min="100"></label>
          <label>Trail Brightness: <input type="number" id="trailBrightnessInput" step="0.1" value="1.0" min="0.1"></label>
        </div>
      </div>
    </details>
    
    <!-- Display Options -->
    <details open>
      <summary>Display Options</summary>
      <div>
        <label><input type="checkbox" id="showStars" checked> Show Stars</label>
      </div>
    </details>
    
    <!-- Presets -->
    <details open>
      <summary>Presets</summary>
      <div id="presets" style="flex-direction: column; gap: 10px;">
        <button id="addSolarSystemBtn" style="align-self: flex-start;">Add Random Solar System</button>
        <div style="display: flex; flex-direction: column; gap: 5px; margin-top:5px;">
          <label>Min Planets: <input type="number" id="minPlanetsInput" value="3"></label>
          <label>Max Planets: <input type="number" id="maxPlanetsInput" value="8"></label>
          <label>Star Mass: <input type="number" id="starMassInput" step="any" value="1000000"></label>
          <label>Base Dist: <input type="number" id="baseDistInput" step="any" value="500"></label>
          <label>Spacing: <input type="number" id="spacingInput" step="any" value="500"></label>
          <label>Offset: <input type="number" id="offsetInput" step="any" value="100"></label>
          <label>Planet Mass Min: <input type="number" id="planetMassMinInput" step="any" value="1000"></label>
          <label>Planet Mass Max: <input type="number" id="planetMassMaxInput" step="any" value="2000"></label>
        </div>
      </div>
    </details>
    
    <!-- Instructions -->
    <details open>
      <summary>Instructions</summary>
      <div id="instructions">
        <p>
          • Click on the canvas (without dragging) to pre-fill position fields or, if a body is clicked, view its info.<br>
          • Drag the canvas to pan.<br>
          • Use the mouse wheel to zoom in and out.<br>
          • Press <strong>Z</strong> to undo the last body placed.<br>
          • Press <strong>T</strong> to toggle trails.
        </p>
      </div>
    </details>
  </div>
  
  <!-- Toggle Sidebar Button -->
  <button id="toggleSidebar">Hide Sidebar</button>
  
  <!-- Planet Info Popup -->
  <div id="planetInfo"></div>
  
  <script>
    /****************************************************
     * JS Code: Simulation with Starry Background, Trails, Collisions, Planet Info Popup,
     * Custom Speed Control, Planet Skins with Detailed Rings, Space Stations,
     * Debug Menu, and a Roche Limit visual toggle with splitting.
     *
     * Additional changes:
     * - The number of fragments for Roche splitting is configurable via the debug menu.
     * - Planetary bodies with the fragment tag won't merge with other fragments.
     * - The "Only Orbit Star" toggle now restricts gravitational interactions so that only bodies interacting with a star (label "Star") affect each other.
     * - New debug menu controls allow adjustment of the Roche limit circle’s color and brightness.
     ****************************************************/
    
    // ========== Simulation Variables & Setup ==========
    const canvas = document.getElementById("simulation");
    const ctx = canvas.getContext("2d");
    const addBodyForm = document.getElementById("addBodyForm");
    const pauseBtn = document.getElementById("pauseBtn");
    const speedInput = document.getElementById("speedInput");
    
    // UI Elements
    const showTrailsCheckbox = document.getElementById("showTrails");
    const usePlanetColorCheckbox = document.getElementById("usePlanetColorCheckbox");
    const trailColorPicker = document.getElementById("trailColorPicker");
    const trailLifespanInput = document.getElementById("trailLifespanInput");
    const trailBrightnessInput = document.getElementById("trailBrightnessInput");
    const showStarsCheckbox = document.getElementById("showStars");
    
    const minPlanetsInput = document.getElementById("minPlanetsInput");
    const maxPlanetsInput = document.getElementById("maxPlanetsInput");
    const addSolarSystemBtn = document.getElementById("addSolarSystemBtn");
    const starMassInput = document.getElementById("starMassInput");
    const baseDistInput = document.getElementById("baseDistInput");
    const spacingInput = document.getElementById("spacingInput");
    const offsetInput = document.getElementById("offsetInput");
    const planetMassMinInput = document.getElementById("planetMassMinInput");
    const planetMassMaxInput = document.getElementById("planetMassMaxInput");
    
    // Debug Elements
    const debugMenu = document.getElementById("debugMenu");
    const closeDebug = document.getElementById("closeDebug");
    const toggleFPSBtn = document.getElementById("toggleFPS");
    const fpsCounter = document.getElementById("fpsCounter");
    const spawnChanceInput = document.getElementById("spawnChanceInput");
    let fpsEnabled = false;
    let stationSpawnChance = 5; // default percentage chance
    let lastFrameTime = performance.now();
    
    // Debug: Roche Splitting Fragments (configurable)
    let numFragments = 4;  // default number of fragments for Roche splitting
    document.getElementById("numFragmentsInput").addEventListener("change", (e) => {
      let val = parseInt(e.target.value, 10);
      if (!isNaN(val) && val >= 2) { 
        numFragments = val;
      }
    });
    
    // New Debug: Roche Limit Circle Color & Brightness
    let rocheLimitColor = "#ff0000";
    let rocheLimitBrightness = 0.3;
    document.getElementById("rocheLimitColorInput").addEventListener("input", (e) => {
      rocheLimitColor = e.target.value;
    });
    document.getElementById("rocheLimitBrightnessInput").addEventListener("change", (e) => {
      let val = parseFloat(e.target.value);
      if (!isNaN(val) && val >= 0 && val <= 1) {
        rocheLimitBrightness = val;
      }
    });
    
    // Toggle for Roche Limit visualization
    const toggleRocheLimitCheckbox = document.getElementById("toggleRocheLimit");
    let showRocheLimit = false;
    toggleRocheLimitCheckbox.addEventListener("change", e => {
      showRocheLimit = e.target.checked;
    });
    
    // Bodies and Stars arrays
    const bodies = [];
    let stars = [];
    
    // Selected body for info
    let selectedPlanet = null;
    
    // Simulation parameters
    const G = 0.1;
    const dt = 1;
    let isPaused = false;
    let speedMultiplier = parseFloat(speedInput.value) || 1;
    
    // Pan & Zoom
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    const dragThreshold = 5;
    
    // Trail settings
    let showTrails = true;
    let maxTrailLength = 2000;
    let trailBrightness = 1.0;
    let usePlanetColor = true;
    let globalTrailColor = "#ff0000";
    let showStars = true;
    
    // Additional controls
    let combineOnCollision = true;
    let onlyOrbitStar = false;
    
    // ========== Space Station Functionality ==========
    class SpaceStation {
      constructor(planet) {
        this.planet = planet;
        // Orbit radius based on planet's size plus an offset
        this.orbitRadius = Math.cbrt(Math.abs(planet.mass)) * 2 + 20;
        this.angle = Math.random() * Math.PI * 2;
        this.speed = 0.005; // Orbital speed
      }
      update() {
        this.angle += this.speed;
        this.x = this.planet.x + Math.cos(this.angle) * this.orbitRadius;
        this.y = this.planet.y + Math.sin(this.angle) * this.orbitRadius;
      }
      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        // Outer circle for the station
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, Math.PI * 2);
        ctx.fillStyle = 'silver';
        ctx.fill();
        // Inner circle detail
        ctx.beginPath();
        ctx.arc(0, 0, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'lightblue';
        ctx.fill();
        // Outline
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }
    }
    // Array to store space stations
    let spaceStations = [];
    // Every 10 seconds, check for bodies with Support Life to spawn a station
    setInterval(() => {
      bodies.forEach(body => {
        if (body.supportLife) {
          const stationExists = spaceStations.some(station => station.planet === body);
          if (!stationExists && Math.random() < (stationSpawnChance / 100)) {
            spaceStations.push(new SpaceStation(body));
          }
        }
      });
    }, 10000);
    
    // ========== Debug Menu Functionality ==========
    document.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "o") { debugMenu.style.display = "block"; }
    });
    closeDebug.addEventListener("click", () => { debugMenu.style.display = "none"; });
    toggleFPSBtn.addEventListener("click", () => {
      fpsEnabled = !fpsEnabled;
      fpsCounter.style.display = fpsEnabled ? "block" : "none";
    });
    spawnChanceInput.addEventListener("change", (e) => {
      let val = parseFloat(e.target.value);
      if (!isNaN(val) && val >= 0 && val <= 100) { stationSpawnChance = val; }
    });
    
    // ========== Utility: Assign Planet Skin ==========
    function assignPlanetSkin(mass) {
      let gasGiant = false;
      let rings = false;
      if (mass >= 3000) {
        gasGiant = (Math.random() < 0.25);
        rings = gasGiant ? (Math.random() < 0.5) : (Math.random() < 0.2);
      } else {
        rings = (Math.random() < 0.1);
      }
      return { gasGiant, rings };
    }
    
    // Helper to convert hex to rgba string
    function hexToRgba(hex, alpha) {
      let r = 0, g = 0, b = 0;
      if (hex.length === 4) {
        r = "0x" + hex[1] + hex[1];
        g = "0x" + hex[2] + hex[2];
        b = "0x" + hex[3] + hex[3];
      } else if (hex.length === 7) {
        r = "0x" + hex[1] + hex[2];
        g = "0x" + hex[3] + hex[4];
        b = "0x" + hex[5] + hex[6];
      }
      return "rgba(" + +r + "," + +g + "," + +b + "," + alpha + ")";
    }
    
    // ========== Event Listeners for Controls ==========
    showTrailsCheckbox.addEventListener("change", e => { showTrails = e.target.checked; });
    usePlanetColorCheckbox.addEventListener("change", e => { usePlanetColor = e.target.checked; });
    trailColorPicker.addEventListener("input", e => { globalTrailColor = e.target.value; });
    trailLifespanInput.addEventListener("input", e => {
      const val = parseInt(e.target.value, 10);
      if (!isNaN(val) && val > 0) { maxTrailLength = val; }
    });
    trailBrightnessInput.addEventListener("input", e => {
      const val = parseFloat(e.target.value);
      if (!isNaN(val) && val > 0) { trailBrightness = val; }
    });
    showStarsCheckbox.addEventListener("change", e => { showStars = e.target.checked; });
    speedInput.addEventListener("input", e => {
      const val = parseFloat(e.target.value);
      if (!isNaN(val)) { speedMultiplier = val; }
    });
    document.getElementById("toggleCombineBtn").addEventListener("click", () => {
      combineOnCollision = !combineOnCollision;
      document.getElementById("toggleCombineBtn").textContent = "Combine on Collision: " + (combineOnCollision ? "ON" : "OFF");
    });
    document.getElementById("toggleOrbitStar").addEventListener("click", () => {
      onlyOrbitStar = !onlyOrbitStar;
      document.getElementById("toggleOrbitStar").textContent = "Only Orbit Star: " + (onlyOrbitStar ? "ON" : "OFF");
    });
    
    // ========== Star Field Functions ==========
    function generateStars() {
      stars = [];
      const starCount = Math.floor((canvas.width * canvas.height) / 1000);
      for (let i = 0; i < starCount; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          radius: Math.random() * 1.5 + 0.5,
          brightness: Math.random() * 0.05 + 0.1
        });
      }
    }
    function drawStars() {
      for (const star of stars) {
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
        ctx.fillStyle = `rgba(255,255,255,${star.brightness})`;
        ctx.fill();
      }
    }
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      generateStars();
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();
    
    // ========== Random Light Color Function ==========
    function getRandomLightColor() {
      const r = Math.floor(Math.random() * 128) + 128;
      const g = Math.floor(Math.random() * 128) + 128;
      const b = Math.floor(Math.random() * 128) + 128;
      return `rgb(${r}, ${g}, ${b})`;
    }
    
    // ========== Collision Detection & Merging ==========
    function checkCollisions() {
      if (!combineOnCollision) return;
      for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {
          // Prevent merging if both bodies are fragments
          if (bodies[i].fragment && bodies[j].fragment) continue;
          
          const dx = bodies[j].x - bodies[i].x;
          const dy = bodies[j].y - bodies[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const r1 = Math.cbrt(Math.abs(bodies[i].mass)) * 2;
          const r2 = Math.cbrt(Math.abs(bodies[j].mass)) * 2;
          if (dist <= r1 + r2) {
            let bigger, smaller;
            if (bodies[i].mass >= bodies[j].mass) {
              bigger = bodies[i];
              smaller = bodies[j];
            } else {
              bigger = bodies[j];
              smaller = bodies[i];
            }
            const totalMass = bigger.mass + smaller.mass;
            bigger.vx = (bigger.mass * bigger.vx + smaller.mass * smaller.vx) / totalMass;
            bigger.vy = (bigger.mass * bigger.vy + smaller.mass * smaller.vy) / totalMass;
            bigger.x = (bigger.mass * bigger.x + smaller.mass * smaller.x) / totalMass;
            bigger.y = (bigger.mass * bigger.y + smaller.mass * smaller.y) / totalMass;
            bigger.mass = totalMass;
            bigger.static = bigger.static || smaller.static;
            bigger.gasGiant = bigger.gasGiant || smaller.gasGiant;
            bigger.rings = bigger.rings || smaller.rings;
            bigger.trail = bigger.trail.concat(smaller.trail);
            smaller.removed = true;
          }
        }
      }
      for (let i = bodies.length - 1; i >= 0; i--) {
        if (bodies[i].removed) {
          if (selectedPlanet === bodies[i]) {
            selectedPlanet = null;
            document.getElementById("planetInfo").style.display = "none";
          }
          bodies.splice(i, 1);
        }
      }
    }
    
    // ========== Roche Limit Splitting ==========
    // If a body (that isn’t already a fragment) is at least 4x smaller than a larger body (mass ratio ≥64)
    // and its center comes within the Roche limit of the larger (defined as 4× the larger's radius),
    // then the smaller body is split into numFragments equal fragments.
    function checkRocheLimit() {
      const toSplit = new Set();
      for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {
          const bodyA = bodies[i];
          const bodyB = bodies[j];
          // Skip if both are fragments (fragments don't interact gravitationally with other fragments)
          if (bodyA.fragment && bodyB.fragment) continue;
          
          // Determine smaller and larger based on computed radii (radius = 2 * ∛mass)
          const radiusA = 2 * Math.cbrt(Math.abs(bodyA.mass));
          const radiusB = 2 * Math.cbrt(Math.abs(bodyB.mass));
          let smaller, larger;
          if (radiusA < radiusB) {
            smaller = bodyA;
            larger = bodyB;
          } else {
            smaller = bodyB;
            larger = bodyA;
          }
          // Larger must be at least 4x the size (by mass, 64×) of the smaller
          if (larger.mass < 64 * smaller.mass) continue;
          
          // Define Roche limit based on the larger body's radius
          const largerRadius = 2 * Math.cbrt(Math.abs(larger.mass));
          const rocheLimit = 4 * largerRadius;
          
          // Compute distance between centers
          const dx = larger.x - smaller.x;
          const dy = larger.y - smaller.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < rocheLimit) {
            toSplit.add(smaller);
          }
        }
      }
      
      // Split each marked body into configurable fragments (if not already a fragment)
      toSplit.forEach(body => {
        if (body.fragment) return;
        const index = bodies.indexOf(body);
        if (index > -1) bodies.splice(index, 1);
        
        const newMass = body.mass / numFragments;
        const bodyRadius = 2 * Math.cbrt(Math.abs(body.mass));
        const offset = bodyRadius;  // offset by the body's radius
        const fragments = [];
        
        for (let k = 0; k < numFragments; k++) {
          const angle = (2 * Math.PI / numFragments) * k;
          fragments.push({
            x: body.x + offset * Math.cos(angle),
            y: body.y + offset * Math.sin(angle),
            vx: body.vx,
            vy: body.vy,
            mass: newMass,
            static: body.static,
            color: body.color,
            trail: [],
            fragment: true,
            label: "Fragment"
          });
        }
        
        fragments.forEach(frag => bodies.push(frag));
      });
    }
    
    // ========== Update Planet Info Popup ==========
    function updatePlanetInfo() {
      const popup = document.getElementById("planetInfo");
      if (selectedPlanet) {
        const screenX = selectedPlanet.x * scale + offsetX;
        const screenY = selectedPlanet.y * scale + offsetY;
        popup.style.left = (screenX + 10) + "px";
        popup.style.top = (screenY - 10) + "px";
        popup.innerHTML = `
          <strong>Type:</strong> ${selectedPlanet.label ? selectedPlanet.label : "Planet"}<br>
          ${selectedPlanet.fragment ? "<strong>Fragment:</strong> Yes<br>" : ""}
          <strong>Mass:</strong> ${selectedPlanet.mass.toFixed(2)}<br>
          <strong>Velocity:</strong> (${selectedPlanet.vx.toFixed(2)}, ${selectedPlanet.vy.toFixed(2)})<br>
          <strong>Static:</strong> ${selectedPlanet.static ? "Yes" : "No"}<br>
          <strong>Gas Giant:</strong> ${selectedPlanet.gasGiant ? "Yes" : "No"}<br>
          <strong>Rings:</strong> ${selectedPlanet.rings ? "Yes" : "No"}<br>
          <strong>Supports Life:</strong> ${selectedPlanet.supportLife ? "Yes" : "No"}
        `;
        popup.style.display = "block";
      }
    }
    
    // ========== Main Simulation Loop ==========
    function loop() {
      const now = performance.now();
      const deltaTime = now - lastFrameTime;
      const fps = 1000 / deltaTime;
      lastFrameTime = now;
      if (fpsEnabled) { fpsCounter.innerText = "FPS: " + Math.round(fps); }
      
      if (!isPaused) {
        updatePhysics(dt * speedMultiplier);
        checkRocheLimit(); // Check for Roche limit-induced splitting
      }
      drawScene();
      // Update and draw space stations
      spaceStations.forEach(station => {
        station.update();
        station.draw(ctx);
      });
      if (selectedPlanet) { updatePlanetInfo(); }
      requestAnimationFrame(loop);
    }
    lastFrameTime = performance.now();
    
    // ========== Physics Update ==========
    function updatePhysics(effectiveDt) {
      const accelerations = bodies.map(() => ({ ax: 0, ay: 0 }));
      for (let i = 0; i < bodies.length; i++) {
        for (let j = i + 1; j < bodies.length; j++) {
          // Skip gravitational force if both bodies are fragments
          if (bodies[i].fragment && bodies[j].fragment) continue;
          // If "Only Orbit Star" is enabled, only compute force if at least one body is a star.
          if (onlyOrbitStar && bodies[i].label !== "Star" && bodies[j].label !== "Star") continue;
          
          const dx = bodies[j].x - bodies[i].x;
          const dy = bodies[j].y - bodies[i].y;
          const distSq = dx * dx + dy * dy;
          const dist = Math.sqrt(distSq) + 0.1;
          const force = G * bodies[i].mass * bodies[j].mass / (distSq + 0.1);
          const fx = force * dx / dist;
          const fy = force * dy / dist;
          accelerations[i].ax += fx / bodies[i].mass;
          accelerations[i].ay += fy / bodies[i].mass;
          accelerations[j].ax -= fx / bodies[j].mass;
          accelerations[j].ay -= fy / bodies[j].mass;
        }
      }
      bodies.forEach((body, index) => {
        if (!body.static) {
          body.vx += accelerations[index].ax * effectiveDt;
          body.vy += accelerations[index].ay * effectiveDt;
          body.x += body.vx * effectiveDt;
          body.y += body.vy * effectiveDt;
        }
        if (!body.trail) { body.trail = []; }
        body.trail.push({ x: body.x, y: body.y });
        if (body.trail.length > maxTrailLength) { body.trail.shift(); }
      });
      checkCollisions();
    }
    
    // ========== Drawing ==========
    function drawScene() {
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (showStars) { drawStars(); }
      ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
      
      // Draw trails
      if (showTrails) {
        bodies.forEach(body => {
          if (body.trail && body.trail.length > 1) {
            for (let i = 1; i < body.trail.length; i++) {
              ctx.save();
              const p1 = body.trail[i - 1];
              const p2 = body.trail[i];
              const alphaStart = 0.2 * trailBrightness;
              const alphaEnd = 1.0 * trailBrightness;
              const alpha = alphaStart + (alphaEnd - alphaStart) * (i / body.trail.length);
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.strokeStyle = usePlanetColor ? (body.color || "#ccc") : globalTrailColor;
              ctx.globalAlpha = alpha;
              ctx.lineWidth = 2;
              ctx.stroke();
              ctx.restore();
            }
          }
        });
      }
      
      // Draw bodies
      bodies.forEach(body => {
        const radius = Math.cbrt(Math.abs(body.mass)) * 2;
        ctx.beginPath();
        if (body.gasGiant) {
          let grad = ctx.createRadialGradient(body.x, body.y, radius * 0.3, body.x, body.y, radius);
          grad.addColorStop(0, body.color);
          grad.addColorStop(1, "#fff");
          ctx.fillStyle = grad;
        } else {
          ctx.fillStyle = body.color || "#ccc";
        }
        ctx.arc(body.x, body.y, radius, 0, 2 * Math.PI);
        ctx.fill();
        if (body.rings) {
          let ringInner = radius * 1.3;
          let ringOuter = radius * 1.7;
          ctx.save();
          ctx.beginPath();
          ctx.arc(body.x, body.y, ringOuter, 0, 2 * Math.PI);
          ctx.arc(body.x, body.y, ringInner, 0, 2 * Math.PI, true);
          let ringGradient = ctx.createLinearGradient(body.x - ringOuter, body.y, body.x + ringOuter, body.y);
          ringGradient.addColorStop(0, "#ddd");
          ringGradient.addColorStop(0.5, "#aaa");
          ringGradient.addColorStop(1, "#ddd");
          ctx.fillStyle = ringGradient;
          ctx.fill("evenodd");
          ctx.lineWidth = 1;
          ctx.strokeStyle = "#888";
          let numLines = 5;
          for (let i = 1; i < numLines; i++) {
            let ringRadius = ringInner + (ringOuter - ringInner) * (i / numLines);
            ctx.beginPath();
            ctx.arc(body.x, body.y, ringRadius, 0, 2 * Math.PI);
            ctx.stroke();
          }
          ctx.restore();
        }
        if (body.mass < 0) {
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      });
      
      // Draw Roche Limit circles if toggled on.
      if (showRocheLimit) {
        bodies.forEach(body => {
          if (!body.fragment) {
            const r = 2 * Math.cbrt(Math.abs(body.mass));
            // Using the same formula for Roche limit as in splitting: 4× the larger body's radius.
            const rocheRadius = 4 * r;
            ctx.beginPath();
            ctx.arc(body.x, body.y, rocheRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = hexToRgba(rocheLimitColor, rocheLimitBrightness);
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        });
      }
    }
    
    // ========== Canvas Events ==========
    canvas.addEventListener("mousedown", (e) => {
      isDragging = false;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
    });
    canvas.addEventListener("mousemove", (e) => {
      if (e.buttons === 1) {
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        if (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold) {
          isDragging = true;
          dragStart.x = e.clientX;
          dragStart.y = e.clientY;
          offsetX += dx;
          offsetY += dy;
        }
      }
    });
    canvas.addEventListener("mouseup", (e) => {
      if (!isDragging) {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const worldX = (x - offsetX) / scale;
        const worldY = (y - offsetY) / scale;
        let clickedPlanet = null;
        for (let body of bodies) {
          const radius = Math.cbrt(Math.abs(body.mass)) * 2;
          const dx = worldX - body.x;
          const dy = worldY - body.y;
          if (Math.sqrt(dx * dx + dy * dy) <= radius) {
            clickedPlanet = body;
            break;
          }
        }
        if (clickedPlanet) {
          selectedPlanet = clickedPlanet;
          updatePlanetInfo();
        } else {
          selectedPlanet = null;
          document.getElementById("planetInfo").style.display = "none";
          document.getElementById("posX").value = worldX.toFixed(2);
          document.getElementById("posY").value = worldY.toFixed(2);
        }
      }
    });
    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const worldX = (mx - offsetX) / scale;
      const worldY = (my - offsetY) / scale;
      scale *= zoomFactor;
      offsetX = mx - worldX * scale;
      offsetY = my - worldY * scale;
    });
    
    // ========== Form & Button Events ==========
    addBodyForm.addEventListener("submit", (e) => {
      e.preventDefault();
      const posX = parseFloat(document.getElementById("posX").value);
      const posY = parseFloat(document.getElementById("posY").value);
      const velX = parseFloat(document.getElementById("velX").value);
      const velY = parseFloat(document.getElementById("velY").value);
      const mass = parseFloat(document.getElementById("mass").value);
      const isStatic = document.getElementById("static").checked;
      // Retrieve tag selections
      const isStar = document.getElementById("tagStar").checked;
      const hasRings = document.getElementById("tagRings").checked;
      const isGas = document.getElementById("tagGas").checked;
      const supportLife = document.getElementById("tagSupportLife").checked;
      const skin = assignPlanetSkin(mass);
      bodies.push({
        x: posX,
        y: posY,
        vx: velX,
        vy: velY,
        mass: mass,
        static: isStatic,
        color: isGas ? "lightblue" : getRandomLightColor(),
        trail: [],
        gasGiant: isGas ? true : skin.gasGiant,
        rings: hasRings || skin.rings,
        label: isStar ? "Star" : undefined,
        supportLife: supportLife
      });
      addBodyForm.reset();
      document.getElementById("velX").value = "0";
      document.getElementById("velY").value = "0";
      document.getElementById("mass").value = "1000";
    });
    document.getElementById("clearFields").addEventListener("click", () => {
      addBodyForm.reset();
      document.getElementById("velX").value = "0";
      document.getElementById("velY").value = "0";
      document.getElementById("mass").value = "1000";
      bodies.length = 0;
    });
    pauseBtn.addEventListener("click", () => {
      isPaused = !isPaused;
      pauseBtn.innerText = isPaused ? "▶️" : "⏸";
    });
    document.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "z") { bodies.pop(); }
      if (e.key.toLowerCase() === "t") {
        showTrails = !showTrails;
        showTrailsCheckbox.checked = showTrails;
      }
    });
    addSolarSystemBtn.addEventListener("click", () => {
      bodies.length = 0;
      const minPlanets = parseInt(minPlanetsInput.value, 10) || 3;
      const maxPlanets = parseInt(maxPlanetsInput.value, 10) || 8;
      const starMass = parseFloat(starMassInput.value) || 1e6;
      const baseDist = parseFloat(baseDistInput.value) || 500;
      const spacing = parseFloat(spacingInput.value) || 500;
      const offsetRange = parseFloat(offsetInput.value) || 100;
      const planetMassMin = parseFloat(planetMassMinInput.value) || 1000;
      const planetMassMax = parseFloat(planetMassMaxInput.value) || 2000;
      // Create central star
      bodies.push({
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        mass: starMass,
        static: true,
        color: "gold",
        trail: [],
        gasGiant: false,
        rings: false,
        label: "Star"
      });
      const planetCount = Math.floor(Math.random() * (maxPlanets - minPlanets + 1)) + minPlanets;
      function orbitalVelocity(r) { return Math.sqrt((G * starMass) / r); }
      for (let i = 0; i < planetCount; i++) {
        const dist = baseDist + i * spacing + Math.random() * offsetRange;
        const mass = planetMassMin + Math.random() * (planetMassMax - planetMassMin);
        const v = orbitalVelocity(dist);
        const skin = assignPlanetSkin(mass);
        bodies.push({
          x: dist,
          y: 0,
          vx: 0,
          vy: v,
          mass: mass,
          static: false,
          color: getRandomLightColor(),
          trail: [],
          gasGiant: skin.gasGiant,
          rings: skin.rings
        });
      }
    });
    
    // ========== Toggle Sidebar ==========
    const toggleSidebarButton = document.getElementById("toggleSidebar");
    const sidebarElement = document.getElementById("sidebar");
    toggleSidebarButton.addEventListener("click", () => {
      if (sidebarElement.style.display === "none") {
        sidebarElement.style.display = "flex";
        toggleSidebarButton.textContent = "Hide Sidebar";
        toggleSidebarButton.style.right = "330px";
      } else {
        sidebarElement.style.display = "none";
        toggleSidebarButton.textContent = "Show Sidebar";
        toggleSidebarButton.style.right = "10px";
      }
    });
    
    loop();
  </script>
</body>
</html>
